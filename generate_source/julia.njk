{% block header %}
{% endblock %}
{% block imports %}
{% block globalimports %}
from traitlets import (
    Unicode, Enum, Instance, Union, Float, Int, List, Tuple, Dict,
    Undefined, Bool, Any
)
{% endblock %}
{% block localimports %}
{% if outputMultiple %}

{% for ref in widgets[0].localDependencies %}
from .{{ ref }} import {{ ref }}
{% endfor %}
{% endif %}
{% endblock %}
{% endblock %}
{% block widgets %}
{% for widget in widgets %}
{% block widget %}
{% if widget.name === "VuetifyWidget" %}
from ipywidgets import DOMWidget
from ipywidgets.widgets.widget import widget_serialization
from ..Events import Events
{% endif %}


mutable struct {{ widget.name }} <: AbstractWidget

{% block widgetbody %}
    _model_name = "{{ widget.name }}Model"

    {% if widget.properties %}
    {% for propName, prop in widget.properties %}
    {{ propName }}::{{ prop.type }} = {% if prop.default %}{{ prop.default }}{% else %}nothing{% endif %}

    {% endfor %}
    {% else %}
    pass
    {% endif %}
{#
# Bug in traitlets, it doesn't set it, which triggers the bug fixed here:
# https://github.com/jupyter-widgets/ipywidgets/pull/1675
# which is not released yet (7.0.2 should have it)
#}
{% if widget.properties %}
{% for propName, prop in widget.properties %}
{% if 'List(None' in prop.traitDef %}
{{ widget.name }}.{{ propName }}.default_value=None
{% endif %}
{% endfor %}
{% endif %}
{% endblock %}
{% endblock %}
{% endfor %}

end

{% endblock %}
{% if outputMultiple %}
__all__ = ['{{ widgets[0].name }}']
{% else %}
__all__ = ['{{ modules | join("', '") }}']
{% endif %}